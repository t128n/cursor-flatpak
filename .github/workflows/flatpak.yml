on:
  workflow_dispatch:
  schedule:
    - cron: '0 */12 * * *'
name: Cursor Flatpak
jobs:
  check-versions:
    runs-on: ubuntu-latest
    outputs:
      cursor_version: ${{ steps.version-check.outputs.cursor_version }}
      flatpak_version: ${{ steps.version-check.outputs.flatpak_version }}
      needs_build: ${{ steps.version-check.outputs.needs_build }}
      cursor_download_url: ${{ steps.version-check.outputs.cursor_download_url }}
    steps:
      - name: Check if new Cursor version is available
        id: version-check
        run: |
          response=$(curl -s "https://www.cursor.com/api/download?platform=linux-x64&releaseTrack=stable")
          cursor_version_val=$(echo "$response" | jq -r '.version')
          cursor_download_url_val=$(echo "$response" | jq -r '.downloadUrl')
          echo "cursor_version=$cursor_version_val" >> $GITHUB_OUTPUT
          echo "cursor_download_url=$cursor_download_url_val" >> $GITHUB_OUTPUT

          response=$(curl -s "https://api.github.com/repos/t128n/cursor-flatpak/releases/latest")
          flatpak_version_val=$(echo "$response" | jq -r '.tag_name')
          echo "flatpak_version=$flatpak_version_val" >> $GITHUB_OUTPUT

          if [ "$cursor_version_val" == "$flatpak_version_val" ]; then
            echo "Cursor version $cursor_version_val matches Flatpak version $flatpak_version_val"
            echo "needs_build=false" >> $GITHUB_OUTPUT
          else
            echo "Cursor version $cursor_version_val does not match Flatpak version $flatpak_version_val"
            echo "needs_build=true" >> $GITHUB_OUTPUT
          fi

  download-appimage:
    needs: check-versions
    if: needs.check-versions.outputs.needs_build == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download Cursor AppImage
        run: |
          echo "Downloading Cursor from ${{ needs.check-versions.outputs.cursor_download_url }}..."
          mkdir -p /tmp
          curl -L -o /tmp/cursor.AppImage "${{ needs.check-versions.outputs.cursor_download_url }}"
      
      - name: Upload AppImage as artifact
        uses: actions/upload-artifact@v4
        with:
          name: cursor-appimage
          path: /tmp/cursor.AppImage
          retention-days: 1

  build-flatpak:
    needs: [check-versions, download-appimage]
    if: needs.check-versions.outputs.needs_build == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to create releases
    container:
      image: ghcr.io/flathub-infra/flatpak-github-actions:freedesktop-23.08
      options: --privileged
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'
          
      - name: Download AppImage artifact
        uses: actions/download-artifact@v4
        with:
          name: cursor-appimage
          path: /tmp

      - name: Extract AppImage and list contents
        run: |
          chmod +x /tmp/cursor.AppImage
          /tmp/cursor.AppImage --appimage-extract 

          if [ ! -d "squashfs-root" ]; then
            echo "ERROR: squashfs-root directory DOES NOT exist after extraction attempt."
            exit 1
          fi
          
      - uses: flatpak/flatpak-github-actions/flatpak-builder@v6
        id: builder # Added id
        with:
          manifest-path: com.cursor.Cursor.json
          cache-key: flatpak-builder-${{ github.sha }}
          branch: stable

      - name: Upload Flatpak artifact
        uses: actions/upload-artifact@v4
        with:
          name: cursor-flatpak-bundle
          path: ${{ steps.builder.outputs.flatpak-file }}
          retention-days: 1
          
  create-release:
    needs: [check-versions, build-flatpak]
    if: needs.check-versions.outputs.needs_build == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download Flatpak artifact
        uses: actions/download-artifact@v4
        with:
          name: cursor-flatpak-bundle # Match the uploaded artifact name
          path: /tmp/flatpak_download # Download to a specific subdirectory
          
      - name: Prepare Flatpak file for release
        id: prepare_file # Give this step an id
        env:
          TARGET_TAG: ${{ needs.check-versions.outputs.cursor_version }}
        run: |
          DOWNLOAD_DIR="/tmp/flatpak_download"
          # The actual .flatpak file should be directly in DOWNLOAD_DIR if 'path' in upload-artifact was a file.
          # If 'path' was a directory, it might be nested. Assuming it's the direct file output by flatpak-builder.
          SOURCE_FLATPAK_FILE=$(find "$DOWNLOAD_DIR" -name "*.flatpak" -type f -print -quit)

          if [ -z "$SOURCE_FLATPAK_FILE" ]; then
            echo "ERROR: No .flatpak file found in $DOWNLOAD_DIR after download."
            echo "Contents of $DOWNLOAD_DIR:"
            ls -R "$DOWNLOAD_DIR"
            exit 1
          fi
          echo "Found Flatpak file: $SOURCE_FLATPAK_FILE"

          DESTINATION_DIR="/tmp/release_assets"
          mkdir -p "$DESTINATION_DIR"
          TARGET_FLATPAK_NAME="com.cursor.Cursor-${TARGET_TAG}.flatpak"
          TARGET_FLATPAK_PATH="$DESTINATION_DIR/$TARGET_FLATPAK_NAME"

          mv "$SOURCE_FLATPAK_FILE" "$TARGET_FLATPAK_PATH"
          echo "Moved and renamed to $TARGET_FLATPAK_PATH"

          echo "flatpak_path=$TARGET_FLATPAK_PATH" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release or Update Existing
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_TAG: ${{ needs.check-versions.outputs.cursor_version }}
          RELEASE_FILE_PATH: ${{ steps.prepare_file.outputs.flatpak_path }} # Use output from new step
        run: |
          # This script will run with RELEASE_FILE_PATH in its environment

          echo "Workflow is attempting to process version: $TARGET_TAG"
          echo "Using file: $RELEASE_FILE_PATH"
          ls -la "$(dirname "$RELEASE_FILE_PATH")" # List directory of the file

          if [ ! -f "$RELEASE_FILE_PATH" ]; then
            echo "ERROR: Expected release file $RELEASE_FILE_PATH not found!"
            exit 1
          fi

          echo "Checking for existing release with tag $TARGET_TAG..."
          if gh release view "$TARGET_TAG" > /dev/null 2>&1; then
            echo "Release $TARGET_TAG already exists."
            echo "Attempting to upload/update asset $RELEASE_FILE_PATH to existing release $TARGET_TAG..."
            gh release upload "$TARGET_TAG" "$RELEASE_FILE_PATH" --clobber
            if [ $? -eq 0 ]; then
              echo "Asset uploaded/updated successfully to existing release $TARGET_TAG."
            else
              echo "Failed to upload asset to existing release $TARGET_TAG."
              # Optionally, exit 1. For now, log and continue.
            fi
          else
            echo "Release $TARGET_TAG does not exist. Creating new release..."
            gh release create "$TARGET_TAG" \
              --title "Cursor $TARGET_TAG" \
              --notes "Cursor $TARGET_TAG packaged as Flatpak. Automatically generated by GitHub Actions." \
              "$RELEASE_FILE_PATH"
            if [ $? -eq 0 ]; then
              echo "Release $TARGET_TAG created successfully."
            else
              echo "Failed to create new release $TARGET_TAG."
              exit 1 # Fail the job if brand new release creation fails
            fi
          fi
